import mime from 'mime';

class ServiceDesk {
    client;
    constructor(client) {
        this.client = client;
    }
    async getServiceDesks(parameters, callback) {
        const config = {
            url: '/rest/servicedeskapi/servicedesk',
            method: 'GET',
            params: {
                start: parameters?.start,
                limit: parameters?.limit,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getServiceDeskById(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}`,
            method: 'GET',
        };
        return this.client.sendRequest(config, callback);
    }
    async attachTemporaryFile(parameters, callback) {
        const formData = new FormData();
        const attachments = Array.isArray(parameters.attachment) ? parameters.attachment : [parameters.attachment];
        // eslint-disable-next-line @typescript-eslint/consistent-type-imports
        let Readable;
        if (typeof window === 'undefined') {
            const { Readable: NodeReadable } = await import('node:stream');
            Readable = NodeReadable;
        }
        for await (const attachment of attachments) {
            const file = await this._convertToFile(attachment, mime, Readable);
            if (!(file instanceof File || file instanceof Blob)) {
                throw new Error(`Unsupported file type for attachment: ${typeof file}`);
            }
            formData.append('file', file, attachment.filename);
        }
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/attachTemporaryFile`,
            method: 'POST',
            headers: {
                'X-Atlassian-Token': 'no-check',
                'Content-Type': 'multipart/form-data',
            },
            data: formData,
        };
        return this.client.sendRequest(config, callback);
    }
    async getCustomers(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/customer`,
            method: 'GET',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
            params: {
                query: parameters.query,
                start: parameters.start,
                limit: parameters.limit,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async addCustomers(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/customer`,
            method: 'POST',
            data: {
                usernames: parameters.usernames,
                accountIds: parameters.accountIds,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async removeCustomers(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/customer`,
            method: 'DELETE',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
            data: {
                usernames: parameters.usernames,
                accountIds: parameters.accountIds,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getArticles(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/knowledgebase/article`,
            method: 'GET',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
            params: {
                query: parameters.query,
                highlight: parameters.highlight,
                start: parameters.start,
                limit: parameters.limit,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getQueues(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/queue`,
            method: 'GET',
            params: {
                includeCount: parameters.includeCount,
                start: parameters.start,
                limit: parameters.limit,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getQueue(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/queue/${parameters.queueId}`,
            method: 'GET',
            params: {
                includeCount: parameters.includeCount,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getIssuesInQueue(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/queue/${parameters.queueId}/issue`,
            method: 'GET',
            params: {
                start: parameters.start,
                limit: parameters.limit,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getRequestTypes(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype`,
            method: 'GET',
            params: {
                groupId: parameters.groupId,
                expand: parameters.expand,
                searchQuery: parameters.searchQuery,
                start: parameters.start,
                limit: parameters.limit,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async createRequestType(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype`,
            method: 'POST',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
            data: {
                issueTypeId: parameters.issueTypeId,
                name: parameters.name,
                description: parameters.description,
                helpText: parameters.helpText,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getRequestTypeById(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype/${parameters.requestTypeId}`,
            method: 'GET',
            params: {
                expand: parameters.expand,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async deleteRequestType(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype/${parameters.requestTypeId}`,
            method: 'DELETE',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getRequestTypeFields(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype/${parameters.requestTypeId}/field`,
            method: 'GET',
            params: {
                expand: parameters.expand,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getPropertiesKeys(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype/${parameters.requestTypeId}/property`,
            method: 'GET',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getProperty(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype/${parameters.requestTypeId}/property/${parameters.propertyKey}`,
            method: 'GET',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async setProperty(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype/${parameters.requestTypeId}/property/${parameters.propertyKey}`,
            method: 'PUT',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async deleteProperty(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttype/${parameters.requestTypeId}/property/${parameters.propertyKey}`,
            method: 'DELETE',
            headers: {
                'X-ExperimentalApi': 'opt-in',
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async getRequestTypeGroups(parameters, callback) {
        const config = {
            url: `/rest/servicedeskapi/servicedesk/${parameters.serviceDeskId}/requesttypegroup`,
            method: 'GET',
            params: {
                start: parameters.start,
                limit: parameters.limit,
            },
        };
        return this.client.sendRequest(config, callback);
    }
    async _convertToFile(attachment, mime, 
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    Readable) {
        const toUint8Array = (input) => {
            if (ArrayBuffer.isView(input)) {
                const view = input;
                const src = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
                const copy = new Uint8Array(src.byteLength);
                copy.set(src);
                return copy;
            }
            const buf = input;
            const src = new Uint8Array(buf);
            const copy = new Uint8Array(src.byteLength);
            copy.set(src);
            return copy;
        };
        const mimeType = attachment.mimeType ?? (mime.getType(attachment.filename) || undefined);
        if (attachment.file instanceof Blob || attachment.file instanceof File) {
            return attachment.file;
        }
        if (typeof attachment.file === 'string') {
            return new File([attachment.file], attachment.filename, { type: mimeType });
        }
        if (Readable && attachment.file instanceof Readable) {
            return this._streamToBlob(attachment.file, attachment.filename, mimeType);
        }
        if (attachment.file instanceof ReadableStream) {
            return this._streamToBlob(attachment.file, attachment.filename, mimeType);
        }
        if (ArrayBuffer.isView(attachment.file) || attachment.file instanceof ArrayBuffer) {
            const arr = toUint8Array(attachment.file);
            return new File([arr], attachment.filename, { type: mimeType });
        }
        throw new Error('Unsupported attachment file type.');
    }
    async _streamToBlob(
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    stream, filename, mimeType) {
        const toUint8Array = (input) => {
            if (ArrayBuffer.isView(input)) {
                const view = input;
                const src = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
                const copy = new Uint8Array(src.byteLength);
                copy.set(src);
                return copy;
            }
            const buf = input;
            const src = new Uint8Array(buf);
            const copy = new Uint8Array(src.byteLength);
            copy.set(src);
            return copy;
        };
        const mergeChunks = (chunks) => {
            const totalLength = chunks.reduce((sum, c) => sum + c.byteLength, 0);
            const merged = new Uint8Array(totalLength);
            let offset = 0;
            for (const c of chunks) {
                merged.set(c, offset);
                offset += c.byteLength;
            }
            return merged;
        };
        if (typeof window === 'undefined' && stream instanceof (await import('node:stream')).Readable) {
            return new Promise((resolve, reject) => {
                const chunks = [];
                stream.on('data', chunk => {
                    if (ArrayBuffer.isView(chunk) || chunk instanceof ArrayBuffer) {
                        chunks.push(toUint8Array(chunk));
                    }
                    else {
                        chunks.push(new Uint8Array(chunk));
                    }
                });
                stream.on('end', () => {
                    const merged = mergeChunks(chunks);
                    const blob = new Blob([merged], { type: mimeType });
                    resolve(new File([blob], filename, { type: mimeType }));
                });
                stream.on('error', reject);
            });
        }
        if (stream instanceof ReadableStream) {
            const reader = stream.getReader();
            const chunks = [];
            let done = false;
            while (!done) {
                const { value, done: streamDone } = await reader.read();
                if (value)
                    chunks.push(toUint8Array(value));
                done = streamDone;
            }
            const merged = mergeChunks(chunks);
            const blob = new Blob([merged], { type: mimeType });
            return new File([blob], filename, { type: mimeType });
        }
        throw new Error('Unsupported stream type.');
    }
}

export { ServiceDesk };
//# sourceMappingURL=serviceDesk.mjs.map
