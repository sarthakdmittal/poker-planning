'use strict';

var mime = require('mime');

class IssueAttachments {
    client;
    constructor(client) {
        this.client = client;
    }
    async getAttachmentContent(parameters, callback) {
        const id = typeof parameters === 'string' ? parameters : parameters.id;
        const config = {
            url: `/rest/api/2/attachment/content/${id}`,
            method: 'GET',
            params: {
                redirect: typeof parameters !== 'string' && parameters.redirect,
            },
            responseType: 'arraybuffer',
        };
        return this.client.sendRequest(config, callback);
    }
    async getAttachmentMeta(callback) {
        const config = {
            url: '/rest/api/2/attachment/meta',
            method: 'GET',
        };
        return this.client.sendRequest(config, callback);
    }
    async getAttachmentThumbnail(parameters, callback) {
        const id = typeof parameters === 'string' ? parameters : parameters.id;
        const config = {
            url: `/rest/api/2/attachment/thumbnail/${id}`,
            method: 'GET',
            params: {
                redirect: typeof parameters !== 'string' && parameters.redirect,
                fallbackToDefault: typeof parameters !== 'string' && parameters.fallbackToDefault,
                width: typeof parameters !== 'string' && parameters.width,
                height: typeof parameters !== 'string' && parameters.height,
            },
            responseType: 'arraybuffer',
        };
        return this.client.sendRequest(config, callback);
    }
    async getAttachment(parameters, callback) {
        const id = typeof parameters === 'string' ? parameters : parameters.id;
        const config = {
            url: `/rest/api/2/attachment/${id}`,
            method: 'GET',
        };
        return this.client.sendRequest(config, callback);
    }
    async removeAttachment(parameters, callback) {
        const id = typeof parameters === 'string' ? parameters : parameters.id;
        const config = {
            url: `/rest/api/2/attachment/${id}`,
            method: 'DELETE',
        };
        return this.client.sendRequest(config, callback);
    }
    async expandAttachmentForHumans(parameters, callback) {
        const id = typeof parameters === 'string' ? parameters : parameters.id;
        const config = {
            url: `/rest/api/2/attachment/${id}/expand/human`,
            method: 'GET',
        };
        return this.client.sendRequest(config, callback);
    }
    async expandAttachmentForMachines(parameters, callback) {
        const id = typeof parameters === 'string' ? parameters : parameters.id;
        const config = {
            url: `/rest/api/2/attachment/${id}/expand/raw`,
            method: 'GET',
        };
        return this.client.sendRequest(config, callback);
    }
    async addAttachment(parameters, callback) {
        const formData = new FormData();
        const attachments = Array.isArray(parameters.attachment) ? parameters.attachment : [parameters.attachment];
        // eslint-disable-next-line @typescript-eslint/consistent-type-imports
        let Readable;
        if (typeof window === 'undefined') {
            const { Readable: NodeReadable } = await import('node:stream');
            Readable = NodeReadable;
        }
        for await (const attachment of attachments) {
            const file = await this._convertToFile(attachment, mime, Readable);
            if (!(file instanceof File || file instanceof Blob)) {
                throw new Error(`Unsupported file type for attachment: ${typeof file}`);
            }
            formData.append('file', file, attachment.filename);
        }
        const config = {
            url: `/rest/api/2/issue/${parameters.issueIdOrKey}/attachments`,
            method: 'POST',
            headers: {
                'X-Atlassian-Token': 'no-check',
                'Content-Type': 'multipart/form-data',
            },
            data: formData,
            maxBodyLength: Infinity,
            maxContentLength: Infinity,
        };
        return this.client.sendRequest(config, callback);
    }
    async _convertToFile(attachment, mime, 
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    Readable) {
        const toUint8ArrayCopy = (input) => {
            if (ArrayBuffer.isView(input)) {
                const view = input;
                const src = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
                const copy = new Uint8Array(src.byteLength);
                copy.set(src);
                return copy;
            }
            const buf = input;
            const src = new Uint8Array(buf);
            const copy = new Uint8Array(src.byteLength);
            copy.set(src);
            return copy;
        };
        const mergeChunks = (chunks) => {
            const totalLength = chunks.reduce((sum, c) => sum + c.byteLength, 0);
            const merged = new Uint8Array(totalLength);
            let offset = 0;
            for (const c of chunks) {
                merged.set(c, offset);
                offset += c.byteLength;
            }
            return merged;
        };
        const mimeType = attachment.mimeType ?? (mime.getType(attachment.filename) || undefined);
        if (attachment.file instanceof Blob || attachment.file instanceof File) {
            return attachment.file;
        }
        if (typeof attachment.file === 'string') {
            return new File([attachment.file], attachment.filename, { type: mimeType });
        }
        if (Readable && attachment.file instanceof Readable) {
            return this._streamToBlob(attachment.file, attachment.filename, mimeType);
        }
        if (attachment.file instanceof ReadableStream) {
            return this._streamToBlob(attachment.file, attachment.filename, mimeType);
        }
        if (ArrayBuffer.isView(attachment.file) || attachment.file instanceof ArrayBuffer) {
            const chunk = toUint8ArrayCopy(attachment.file);
            const merged = mergeChunks([chunk]);
            const blob = new Blob([merged], { type: mimeType });
            return new File([blob], attachment.filename, { type: mimeType });
        }
        throw new Error('Unsupported attachment file type.');
    }
    async _streamToBlob(
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    stream, filename, mimeType) {
        const mergeChunks = (chunks) => {
            const totalLength = chunks.reduce((sum, c) => sum + c.byteLength, 0);
            const merged = new Uint8Array(totalLength);
            let offset = 0;
            for (const c of chunks) {
                merged.set(c, offset);
                offset += c.byteLength;
            }
            return merged;
        };
        if (typeof window === 'undefined' && stream instanceof (await import('node:stream')).Readable) {
            return new Promise((resolve, reject) => {
                const chunks = [];
                stream.on('data', (chunk) => {
                    chunks.push(new Uint8Array(chunk));
                });
                stream.on('end', () => {
                    const merged = mergeChunks(chunks);
                    const blob = new Blob([merged], { type: mimeType });
                    resolve(new File([blob], filename, { type: mimeType }));
                });
                stream.on('error', reject);
            });
        }
        if (stream instanceof ReadableStream) {
            const reader = stream.getReader();
            const chunks = [];
            let done = false;
            while (!done) {
                const { value, done: streamDone } = await reader.read();
                if (value)
                    chunks.push(new Uint8Array(value));
                done = streamDone;
            }
            const merged = mergeChunks(chunks);
            const blob = new Blob([merged], { type: mimeType });
            return new File([blob], filename, { type: mimeType });
        }
        throw new Error('Unsupported stream type.');
    }
}

exports.IssueAttachments = IssueAttachments;
//# sourceMappingURL=issueAttachments.cjs.map
